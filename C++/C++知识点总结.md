# C++知识点总结

# 1. 静态与常量

1. 静态局部变量直到程序终止时才退出
2. 常量数据成员只能在定义时初始化或者在构造函数里用成员初始化值来初始化，不能用赋值语句来初始化
3. 常量数据成员只能在定义时初始化或者在构造函数里用成员初始化值来初始化，不能用赋值语句来初始化
4. 用const char\* ptr 表示ptr指向的字符串为常量字符串，而char\* const ptr表明ptr本身为常量指针。如果const出现在左边，说明所指对象的是常量，如果const出现在右边，则说明指针本身是常量
5. `const int* i = &a;`只是代表不能通过i指针来修改，但是可以通过其它途径来修改a，例如 `a = 3;`
6. 非const对象可以调用const和非const函数，但是const对象只能调用const函数，常量成员函数可以有非常量版本的重载
7. 可以使用非const类型变量赋给const类型参数，不能用const类型变量赋值给非const类型参数
8. 函数的const版本可以和原版本重载，用非const函数调用const函数可以减少代码重复
9. 尽量不要在类中使用静态变量，永远不要做运行期静态初始化
10. mutable变量可以在const函数中被修改，其效果好于const_cast<>，所以尽量使用mutable
11. 使用函数返回静态对象将non-local static对象转化为local static对象

# 2. 类与继承

1. struct成员默认访问方式是public，而class默认访问方式是private
2. 类的继承要么用public，要么友元函数，其它如protected继承后的函数交叉调用可能会出现问题
3. 一个类内对象内部函数可以访问对象自己的私有成员变量，但是如果有一个同类的另一个对象作为函数的参数，则该内部函数也可以访问另一个对象的私有成员变量
4. 通过public函数返回private成员的引用有可能会破坏类的封装，造成外部变量可以改变类私有成员值
5. 派生类赋值给基类是不要使用对象继续赋值，而是使用指针或引用以避免发生截切
6. 函数对象就是重载了operator()的class对象，使用函数对象生成匿名临时对象是好的编程习惯
7. 如果父类中函数是虚拟函数，那么在每个子类中显式声明虚函数是好的编程习惯
8. 子类在继承父类时如果重写父类的虚函数或者非虚函数，要保证在子类中重写的函数访问修饰符和父类结合继承访问后得到的访问修饰符结果一致
9. 如果一个函数和类相关，但不是成员函数，那么该函数也不一定非得是友元函数，如果函数能通过类的公共接口完成功能，则完全不必声明为友元函数，但该函数返回值一般是const

# 3. 构造与析构

1. 析构函数必须被定义。定义一个类时，析构函数（释放资源）和拷贝构造函数（深拷贝）最好显式定义
2. exit()函数终止程序执行会调用析构函数，abort()函数终止程序不会调用析构函数
3. 类参数传值传递是调用拷贝构造函数，多用const引用
4. 要在析构函数里面使用delete来释放使用new申请的内存空间，编写析构函数来释放类中成员所申请的内存空间和使用深拷贝函数是好的编程习惯
5. 析构函数绝对不要吐出异常，即使出现异常也要在析构函数内部处理，要么结束要么吞下
6. 构造函数如果不是explicit则可以进行隐式类型转换，不管构造函数有几个参数，但前提是如果你给的实际参数个数小于构造函数需求参数个数，你得保证构造函数有默认构造参数
7. 派生类中的拷贝构造函数和赋值符号不会自动拷贝或赋值基类部分，所以要显式调用基类拷贝或赋值函数
8. 如果类作为基类，其析构函数要声明为虚析构函数，这样派生类才可以调用自己的析构函数
9. 在派生类构造函数中尽量多使用成员初始化列表，静态数据成员和数组不允许在成员初始化表中进行初始化
10. 构造函数和析构函数可以被子类继承，但如果析构函数是虚函数，继承的子类的析构函数也默认是虚函数，但你最好加上virtual增加可读性
11. 可以通过在private区域声明拷贝构造函数来禁止类的复制初始化
12. 对class对象或者有可能是class对象的实体进行直接初始化而不是用赋值语句初始化
13. C++中有时在类构造函数前加上explicit关键字来禁止隐式类型转换，可以减少很多错误
14. `wget w1=w2;`调用拷贝构造函数，而`wget w1; w1=w2;`调用的是类赋值运算符
15. 在类中涉及到指针和引用等，最好显式撰写深拷贝构造函数和赋值运算符重载operator=()，以免出现错误
16. 虚析构函数都是public，没有其它的像private和protected类型的
17. 在写拷贝构造函数和重写赋值运算符函数时必须把类中所有变量都用'='号显式写全了，不要写一部分，如果你没写，则编译器只会调用默认构造函数进行变量初始化，而不会默认用'='号
18. 搞清楚复制初始化和赋值初始化的不同，复制初始化是调用拷贝构造函数实现，而赋值是重载'='实现
19. 使用类的构造函数和析构函数来封装一些成对的操作如加锁和解锁等，这样在函数执行开始时创建类对象，使用`A a;`而不是`A a();`或`A()`来创建，在函数结束前会自动删除改对象，也就实现了开始时调用加锁操作，结束时调用解锁操作，俗称RAII(资源获取即初始化)
20. 不要在构造函数和析构函数中调用virtual函数，因为它们不会下降到derived class类别，用向上传递参数替换

# 4. 多态

1. 不要在虚函数中提供参数的默认初始化物
2. 多使用虚函数实现不同的功能，把基类尽量细分成更小的基类
3. 使用动态绑定而不是条件式的分派实现类型相关的需求
4. 可以通过声明纯虚析构函数来定义一个抽象类，这时纯虚析构函数必须给出定义才行
5. 如果某个类型可能成为基类，则一开始就把它写成抽象基类
6. 接口类就是没有数据成员，析构函数声明为虚函数，普通成员函数皆为纯虚函数，不声明构造函数的类型
7. 以public方式继承的基类一般应该是抽象的，应该集中精力于接口继承而不是代码复用
8. 每种类有一个vtable，每个对象有一个vptr，RTTI是在vtable中增加一项，所以只会增加类大小，而不会增加对象大小
9. virtual函数即使是private函数且被private继承，虽然对于派生类不可访问，但派生类还是可以继承基类virtual函数并重写的，并无影响

# 5. 动态内存

1. 在局部函数中用new创建的变量是存在内存中的，即便局部函数执行完毕内存变量仍然存在，但是指向它的指针有可能是局部变量，则需要在局部函数结束前调用delete释放内存空间，以免内存泄漏
2. 在进行指针重新复制时一定要注意是否可能造成内存泄漏，是否要先释放当前指针所指内存空间
3. 不要返回函数作用域内所分配的存储的引用（返回指针或直接传值可以），会造成内存泄漏
4. 在析构函数中释放资源，尽量使用引用来捕捉异常，而不用传值或指针
5. 在释放内存空间时先把原指针所指内存区域备份，再删除或指向新的内存空间，再delete原来备份的区域
6. 多使用tr1::shared_ptr和auto_ptr智能指针来自动释放内存空间

# 6. 输入输出

1. std::istream输入read()是从文件中读取，std::ostream输出write()是写到文件中去
2. std::istream是seekg()重置文件指针位置，std::ostream是seekp()，文件用std::file.eof()来判断是否读取到文件尾部
3. `std::cout << std::setiosflags(ios::fixed) << std::setprecision(n);`用来设置C++中输出小数点后位数，但是C语言的`printf(“%.9lf”, a);`比C++的setprecision(10)来的更加精确，C++有时会自动舍入精度

# 7. 操作符与重载

1. operator++()是相当于++i，operator++(int)是相当于i++。前置式总是优于后置式，即++i总是优于i++。
2. 优先级：i++高于++i，注意，具体运算符优先级看运算符优先级表
3. 用户自定义版本的后置式形式自增自减运算符应该返回常量，因为后置后置不能作为左值
4. assert(条件)，当满足条件时就不assert，不满足条件才会assert
5. 类重载二元运算符时，要么作为类的只带一个参数的内部函数，要么作为类中带两个参数的友元函数
6. ++i返回的是内存变量，可以作为左值也可以作为右值，而i++返回的是字面量，不占内存，不能作为左值右值
7. 内建的operator->是二元的，而重载的operator->是一元的，如果重载了operator->则先调用重载的，直到重复调用到内建的operator->才终止
8. 令赋值操作符返回一个reference to \*this
9. 重载必须在同一个类作用域下才构成重载，否则只是遮掩
10. 重载某个操作符时应该返回引用而不是指针
11. 在C++类中尽量不要重载类型转换operator函数，而是使用有明确含义的如toInt()，toChar()等函数替代
12. 派生类中对基类中的非虚函数的重写或重载其实是遮掩，会将基类中同名的所有虚函数和非虚函数全部遮掩，使之无效，这时想要构成重载，必须使用using A::fun()函数来导入基类中fun函数
13. 重载虚函数要么对基类中的每一个都重写要么一个都不要重写，或者使用using A::fun()
14. 类重载运算符时有时必须参数和函数都是const，这样保证在其他函数调用时即使传递常量参数也没问题

# 8. 引用

1. C++中尽量避免使用指针，而是使用引用
2. 引用和指针一样支持多态性，因为引用的内部就是通过指针实现的
3. 指针可以改变其指向的对象，但是引用不行，引用一旦赋值后不能改变
4. 引用的赋值相当于把等号右边别名所指的对象值替换了等号左边别名所指对象的值，还是2个对象
5. 多用引用传递参数，用值传递时会有大量的复制操作，效率很低，多用引用是好的编程习惯
6. 前缀返回引用，后缀返回const value，后缀通过前缀实现，前缀效率比后缀高
7. 对象作为参数尽量使用引用传递，其次考虑指针，尽量不要用值传递，如果不想修改对象可以加const
8. 对于内置类型、STL和函数对象，传值比较高效，但是对于其它类型，传递常量引用比较高效
9. shared_ptr对象如果有多个指向一个指针，则只有第一个需要使用指针初始化，其他的要么用拷贝构造函数，要么用赋值运算符初始化，指针初始化只能用一次
10. 对于不需要修改的变量，使用常量引用来传递参数可以既保证安全性又保证效率

# 9. 指针与类型转换

1. 当使用类型转换太麻烦时，不妨就使用模板吧
2. 类中尽量不要定义类型转换符号，即使定义也没有返回类型，因为类型转换符本身已经规定了返回类型
3. 编译器默认隐式转换最多只能转换一次，超过一次就被禁止
4. 使用dynamic_cast<>，static_cast<>，const_cast<>，reinterpret_cast<>
5. 操作符->优先级高于\*
6. 对灵巧指针绝对不要提供一个转换到原始指针类型的转换操作符
7. 一定要为含有指针的类提供深拷贝构造函数，以免在以后的运用中出现错误
8. 不使用void\*为类型转换的中介类型是良好的编程习惯，因为void\*会抹除指针的类型信息
9. 每一个重载运算符必须自带至少一个用户自定义类型的参数
10. 常量引用是会创建临时变量的，这时会发生隐式类型转换
11. C++禁止为非常量引用创建临时变量，所以非常量引用传递参数时不会发生隐式类型转换
12. 在C++中使用0来对指针初始化可以保证数字字面常量0可以转换成任何一种指针类型对应的空指针
13. 在类对象中尽量避免使用二级指针，尤其是在基类指向派生类对象的指针时尤其要注意
14. 非成员友员允许在第一个参数上施行类型转换，而成员函数不能在第一个参数上施行类型转换
15. 尽量避免使用转型，即使必须使用也得使用C++特定的如static_cast等!
16. auto_ptr对象最好使用const引用传递，而不要用值传递

# 10. STL容器

1. C++中STL容器的工作方式是对内建类型是位拷贝，自定义对象是存入对象的拷贝，使用insert或是push_back时都是使用拷贝，如果创建对象时是在堆中，则传指针给STL，如果在栈中，则传递对象本身
2. 尽量不使用class数组，多用STL容器，如vector，而且容器类型是指针而不是对象，如vector
3. C++中使用STL容器时，若对象拷贝动作较多，基类又要记录派生类，则存放指针，若是基本类型或者很少拷贝，则存放对象
4. 使用引用类型或标准库组件以避免引入多级指针的复杂性是较佳的设计
5. STL中对于iterator尽量运用(\*iterator).first来取值，而不是用->来取值
6. 模板和异常规格不要混合使用，异常规格是一个应该被审慎使用的特性
7. 永远不要把auto_ptr实例化的类型作为STL容器的基本类型
8. 要使得栈中的基本元素是模板类类型，必须要定义模板类的一些函数：默认构造函数，友员输出函数等
9. 不要将auto_ptr对象作为函数参数按值传递，会清空原有对象，造成不可预知的错误

# 11. 其他

1. 一维数组形参如下:int a[]，二维数组形参如下:int a，第一个[]是空的，后面必须非空
2. for循环中使用continue不会出现死循环，但是while中使用continue容易出现死循环，因为可能i没有自加
3. 对于平凡整型常量，可以用枚举量来表示
4. 复制操作不经由模板成员函数来实现，必须显式给出复制操作的实现
5. `enum {star = 5};`这里定义的star可以当作常量字面量来用，和#definestar5效果是一样的
6. 尽量使用const，enum，inline来代替#define，使用模板inline函数代替宏
7. 对于单纯常量，最好用const和enum代替#define，对于形似函数的宏，最好使用inline函数来替代
8. 将十进制化为二进制或判断能否被2整除或者除以2可以使用右移操作和&1操作
9. C++和C语言中，把整数赋值给字符变量，是将整数当作ASCII码赋给字符变量，将字符变量赋值给整数也是将字符变量对应的ASCII码赋给整数
10. 访问层级(public protected private)对重写虚函数没有任何影响，即使public继承，你也可以将继承过来的本来应该是public的函数写到private作用域中，完全可以
11. 根据实际需要选准模式，是is-a还是has-a，private继承和has-a类似，但是一般都是会选择has-a
12. 因为private继承不是is-a关系，所以不能满足基类指针指向派生类的情况，当然不能使用多态性，只能看作是和has-a一样的情况了
13. 抛出匿名临时异常对象，并以引用的方式捕获它们，如需重新抛出，则抛出既有的异常对象，而非处理原始的异常之后，抛出一个新的异常对象