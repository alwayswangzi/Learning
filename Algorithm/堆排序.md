# 堆排序

堆排序（heap sort）是利用堆的数据结构所设计的一种排序算法，因此在学习堆排序之前，有必要了解**二叉堆**的原理与实现。

我们知道，堆分为最大堆和最小堆。最大堆通常被用来进行升序排序，而最小堆通常被用来进行降序排序。基于最大堆和最小堆是对称关系，所以只需要理解一种即可。下面对最大堆实现的升序排序进行详细说明。

最大堆进行升序排序的基本思想：

1. 初始化堆：将数列a[0...n-1]构造成最大堆。
2. 交换数据：将a[0]与a[n-1]交换，使a[n-1]是a[1...n-1]中的最大值
3. 重新调整堆：将a[0...n-2]重新调整为最大堆
4. 重复：将a[0]与a[n-2]交换，重复2，3过程，直到整个数列都是有序的

下面复习一下数组实现的二叉堆的性质，第一个元素的位置为0：

1. 位置为i的元素的左孩子是2*i+1
2. 位置为i的元素的右孩子为2*i+2
3. 位置为i的元素的父节点为floor((i-1)/2)

## 算法

### 1. 初始化堆

原始数组为[20 30 90 40 70 110 60 10 100 50 80]

要转换为最大堆，从最后一个元素n-1的父节点(n-1-1)/2开始，向下调整堆，这样就能保证每个父节点都能大于左右子节点。

i=(11-1-1)/2=4

![img](http://images.cnitblog.com/i/497634/201403/151549357156092.jpg)

i=3

![img](http://images.cnitblog.com/i/497634/201403/151550457307269.jpg)

i=2

![img](http://images.cnitblog.com/i/497634/201403/151551282937167.jpg)

i=1

![img](http://images.cnitblog.com/i/497634/201403/151552295278892.jpg)

i=0

![img](http://images.cnitblog.com/i/497634/201403/151553325277045.jpg)

调整完毕，就得到了最大堆。

### 2. 交换数据

在将数组转换成最大堆之后，接着要进行交换数据，从而使数组成为一个真正的有序数组。

交换数据部分相对比较简单，下面仅仅给出将最大值放在数组末尾的示意图。

![img](http://images.cnitblog.com/i/497634/201403/151554424963237.jpg)

上面是当n=10时，交换数据的示意图。

当n=10时，首先交换a[0]和a[10]，使得a[10]是a[0...10]之间的最大值；然后，调整a[0...9]使它称为最大堆。交换之后：a[10]是有序的。

当n=9时， 首先交换a[0]和a[9]，使得a[9]是a[0...9]之间的最大值；然后，调整a[0...8]使它称为最大堆。交换之后：a[9...10]是有序的。

...

依此类推，直到a[0...10]是有序的。

### 3. 代码

```cpp
// 最大堆的向下调整算法
void maxheap_filter_down(int a[], int start, int end)
{
	int current = start;
	int left_child = 2*current+1;
	int tmp = a[current];
	
	while(left_child <= end)
	{
		if(left_child + 1 <= end && a[left_child] < a[left_child + 1])
			left_child++;
		
		if(tmp >= a[left_child])
			break;
		else
		{
			a[current] = a[left_child];
			current = left_child;
			left_child = 2 * current + 1;
		}
	}
	a[current] = tmp;
}

void swap(int *a, int *b)
{
	int tmp = *a;
	*a = *b;
	*b = tmp;
}

// 堆排序(从小到大)
void heap_sort_asc(int a[], int n)
{
	int i;
	// 从(n-1-1)/2-->0逐次遍历
	// 遍历之后，得到的数组实际上是一个最大二叉堆
	for(i = (n-1-1)/2; i >= 0; i--)
		maxheap_filter_down(a, i, n-1);
	
	// 从最后一个元素开始对序列进行调整
	// 不断的缩小调整的范围直到第一个元素
	for(i = n-1; i > 0; i--)
	{
		// 交换后，a[i]是a[0...i]中最大的
		swap(&a[0], &a[i]);
		// 调整a[0...i-1]，使得a[0...i-1]仍然是一个最大堆
		maxheap_filter_down(a, 0, i-1);
	}
}
```

## 堆排序的时间复杂度和稳定性

**堆排序时间复杂度**

堆排序的时间复杂度是O(N*lgN)。

假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？

堆排序是采用的二叉堆进行排序的，二叉堆就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。最多是多少呢？由于二叉堆是完全二叉树，因此，它的深度最多也不会超过lg(2N)。因此，遍历一趟的时间复杂度是O(N)，而遍历次数介于lg(N+1)和lg(2N)之间；因此得出它的时间复杂度是O(N*lgN)。

**堆排序稳定性**

堆排序是不稳定的算法，它不满足稳定算法的定义。它在交换数据的时候，是比较父结点和子节点之间的数据，所以，即便是存在两个数值相等的兄弟节点，它们的相对顺序在排序也可能发生变化。

*注：算法稳定性 -- 假设在数列中存在a[i] = a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的*