# 冒泡排序算法的实现与改进

冒泡排序是最简单的排序算法之一，它的时间复杂度为O(n^2)。其基本思想是通过相邻两个数的比较交换，将较大的“沉”到底下去，较小的“浮”上来。

设数组长度为N，以从小到大排序举例：

1. 对于整个未排序的数组，依次比较前后两个数据。如果前面的数据大于后面的，就把这两个数据交换位置；
2. 这样对数组从0到N-1的所有位置进行一次遍历之后，最大的数据就“沉”到第N-1位置；
3. 令N=N-1，若N不为0则重复1、2两步，若N为0则排序完成。

按照上述的定义实现的代码

```cpp
void BubbleSort1(int a[], int n)
{
    int i,j;
  	for(int i = 0; i < n; i++)
    {
      	for(j = 1; j < n-i; j++)
        {
          	if(a[j-1] > a[j])
            	swap(a[j-1], a[j]);
        }
    }
}
```

这种实现方法的缺点之一就是：即使第一趟排序之后数组已经有序了，但是还是要进行后面的N-1趟无效比较。

因此优化：设置一个标志，如果这一趟发生了交换，则为true，否则为false。如果有一趟没有发生交换，说明排序已经完成。

```cpp
void BubbleSort2(int a[], int n)
{
    int i,j;
  	bool flag = true;
  	for(int i = 0; i < n; i++)
    {
      	flag = false;
      	for(j = 1; j < n-i; j++)
        {
          	if(a[j-1] > a[j])
            {
                swap(a[j-1], a[j]);
              	flag = true;
            }    	
        }
      	if(flag == false)
          	break;
    }
}
```

再做进一步的优化。如果有100个数的数组，仅前面10个无序，后面90个都已排好序且都大于前面10个数字，那么在第一趟遍历后，最后发生交换的位置必定小于10，且这个位置之后的数据必定已经有序了，记录下这位置，第二次只要从数组头部遍历到这个位置就可以了。

举例：

原始数组：

​	3 2 1 4 5 6 flag=6

第一趟：(下划线代表当前比较的两个数，黑体代表交换)

​	<u>**2 3**</u> 1 4 5 6 flag=1

​	2 <u>**1 3**</u> 4 5 6 flag=2 

​	2 1 <u>3 4</u> 5 6 flag=2

​	2 1 3 <u>4 5</u> 6 flag=2

​	2 1 3 4 <u>5 6</u> flag=2

第二趟：

​	<u>**1 2**</u> 3 4 5 6 flag=1

排序结束	

```cpp
void BubbleSort3(int a[], int n)
{
    int j,k;
  	int flag = n;
  	while(flag > 0)
    {
    	k = flag;
      	flag = 0;
      	for(j = 1; j < k; j++)
        {
            if(a[j-1] >　a[j])
            {
                swap(a[j-1], a[j]);
              	flag = j;
            }
        }
    } 	
}
```

冒泡排序毕竟是一种效率低下的排序方法，在数据规模很小时，可以采用。数据规模比较大时，最好用其它排序方法。

**评语：**

**原文作者的改进思路比较新颖，但效果不是很明显。经测试，对于随机数组第一个最快，其他两个反而都要稍慢一点点，原因是内层循环多了个赋值语句（内层循环的指令数影响很明显的），而对于随机数列实际能减少的循环次数几乎可忽略（精测试1%数量级的），原因是时间浪费在了内存空间的分配和读写上。冒泡排序本身就是一种时间换取空间的办法，那么后两种会因为每次的赋值运算导致性能下降。**