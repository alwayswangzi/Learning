# TCP粘包问题及解决方法

TCP是一个流协议。所谓流，就是没有界限的一串数据。但一般通讯程序开发是需要定义一个个相互独立的数据包的，比如用于登陆的数据包，用于注销的数据包等等。由于TCP流的特性以及网络状况的时刻变化，在进行数据传输时会出现以下几种情况。

假设我们连续调用两次send分别发送两段数据data1和data2，在接收端有以下几种接收情况（当然不止这几种情况，这里只列出了有代表性的情况）。

1. 先接收到data1，然后接收到data2
2. 先接收到data1的部分数据，然后接收到data1余下的部分以及data2的全部数据
3. 先接收到了data1的全部数据和data2的部分数据，然后接收到了data2的余下的数据
4. 一次性接收到了data1和data2的全部数据

对于1这种情况正是我们需要的。对于2、3、4的情况就是大家经常说的“粘包”现象，就需要我们把接收到的数据进行拆包，拆成一个个独立的数据包。为了拆包就必须在发送端进行封包。

## 1. 什么时候需要考虑粘包问题？

- 如果利用tcp每次发送数据，就与对方建立连接，然后双方发送完一段数据后，就关闭连接，这样就不会出现粘包问题。
- 如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就ok，也不用考虑粘包。
- 如果双方建立连接，需要在连接后一段时间内发送不同结构数据，如连接后，有好几种结构，这时就要考虑粘包的问题。

## 2. 粘包出现的原因

对于UDP来说就不存在拆包的问题，因为UDP是个数据包协议，也就是两段数据间是有界限的，在接收端要么接收不到数据要么就是接收一个完整的一段数据，不会少接收也不会多接收。

1.  发送端需要等缓冲区满才发送出去，造成粘包。
2. 接收方不及时接收缓冲区的包，造成多个包接收。

## 3. 解决办法

为了避免粘包现象，可以采取以下几种措施：

1. 对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；
2. 对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；
3. 由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。

## 4. 上述解决措施的不足之处

1. 第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。
2. 第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。
3. 第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。

## 5. 改进的防粘包措施

封包和拆包。

### 封包

给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了（根据需要也可以加入包尾部分）。

包头其实上是个大小固定的结构体，其中有个结构体成员变量表示包体的长度。这是个很重要的变量，其他的结构体成员可根据需要自己定义。根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。

### 拆包

对于拆包目前最常用的有两种方式：

#### （1）动态缓冲区暂存

大概过程描述如下：

1. 为每一个连接动态分配一个缓冲区，同时把此缓冲区和Socket关联，常用的是通过结构体关联。
2. 当接收到数据时首先把此段数据存放在缓冲区中。
3. 判断缓存区中的数据长度是否够一个包头的长度。如不够，则不进行拆包操作。
4. 根据包头数据解析出里面代表包体长度的变量。
5. 判断缓存区中除包头外的数据长度是否够一个包体的长度。如不够，则不进行拆包操作。
6. 取出整个数据包。这里的"取"的意思是不光从缓冲区中拷贝出数据包，而且要把此数据包从缓存区中删除掉。删除的办法就是把此包后面的数据移动到缓冲区的起始地址。

这种方法有两个缺点：

1. 为每个连接动态分配一个缓冲区增大了内存的使用。
2. 有三个地方需要拷贝数据。一个地方是把数据存放在缓冲区，一个地方是把完整的数据包从缓冲区取出来，一个地方是把数据包从缓冲区中删除。

#### （2）利用底层的缓冲区来进行拆包

由于TCP也维护了一个缓冲区，所以我们完全可以利用TCP的缓冲区来缓存我们的数据，这样一来就不需要为每一个连接分配一个缓冲区了。另一方面我们知道recv或者wsarecv都有一个参数，用来表示我们要接收多长长度的数据。利用这两个条件我们就可以对第一种方法进行优化。

对于阻塞SOCKET来说，我们可以利用一个循环来接收包头长度的数据，然后解析出代表包体长度的那个变量，再用一个循环来接收包体长度的数据。

对于非阻塞的SOCKET，比如完成端口，我们可以提交接收包头长度的数据的请求。当 GetQueuedCompletionStatus返回时，我们判断接收的数据长度是否等于包头长度。若等于，则提交接收包体长度的数据的请求，若不等于，则提交接收剩余数据的请求。当接收包体时，采用类似的方法。

