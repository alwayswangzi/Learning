# 浅谈C/C++内存泄漏及检测手段

## 内存泄漏的定义

一般我们常说的内存泄漏是指堆内存的泄漏。堆内存是程序员通过malloc或者new主动申请的，使用完之后必须显式的释放掉，否则这块内存就不能再次使用，我们就称这块内存泄漏了。

内存泄漏有以下常见的情形：

1. 在函数内部申请一块动态内存，但是在释放之前函数就return了，造成了内存泄漏；
2. 广义的说，内存泄漏不仅仅包括堆内存的泄漏，页包括系统内存的泄漏，比如系统核心态Handle、Socket、Interface等。所以在调用系统函数的时候，没有按照正确的使用规范也可能造成内存的泄漏，并且这种情况更严重，因为消耗的是核心态的内存，严重时会导致系统不稳定。

## 内存泄漏的发生方式

以发生的方式来分类，内存泄漏可以分为4类：

1. 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次执行都会导致一块内存泄漏。
2. 偶发性内存泄漏。发生内存泄漏的代码只在某些特定情况或操作下才会发生。
3. 一次性内存泄漏。发生内存泄漏的代码只会被执行依次，或者由于算法上的缺陷，导致总有一块内存发生泄漏。
4. 隐式内存泄漏。程序运行过程中不停地分配内存，但是直到结束的时候才释放内存。严格的说并没有发生内存泄漏，但是对于一个后台不断运行的服务程序，不及时释放内存最终会导致耗尽系统所有内存资源，所以称这类内存泄漏为隐式内存泄漏。

从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作 为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危 害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到。

## 如何检测内存泄漏

检测内存泄漏的关键是**要能捕获对内存的分配和释放的两个函数调用**。捕获住这两个函数，我们就能跟踪每一 块内存的生命周期，比如，每当成功的分配一块内存后，就把它的指针加入一个全局的list中；每当释放一块内存，再把它的指针从list中删除。这样，当 程序结束的时候，list中剩余的指针就是指向那些没有被释放的内存。

如果要检测堆内存的泄漏，那么需要截获住 malloc/realloc/free和new/delete就可以了。对于其他的泄漏，可以采用类似的方法，截获住相应的分配和释放函数。

### Windows平台

在Windows平台下，检测内存泄漏的工具常用的一般有三种：

- MS C-Runtime Library内建的检测功能；
- 外挂式的检测工具，诸如，Purify，BoundsChecker等；
- 利用Windows NT自带的Performance Monitor。

这三种工具各有优缺点。MS C-Runtime Library虽然功能上较之外挂式的工具要弱，但是它是免费的；Performance Monitor虽然无法标示出发生问题的代码，但是它能检测出隐式的内存泄漏的存在，这是其他两类工具无能为力的地方。

以下我们详细讨论这三种检测工具：

#### （1）MS C-Runtime Library

程序也可以利用MS C-Runtime Library的Debug Function加入内存泄漏的检测功能。MS C-Runtime Library在实现malloc/free，strdup等函数时已经内建了内存泄漏的检测功能。

### Linux平台

#### （1）不借助第三方工具

[如何在linux下检测内存泄漏]: https://www.ibm.com/developerworks/cn/linux/l-mleak/

#### （2）使用valgrind工具

