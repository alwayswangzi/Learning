# 条款13：以对象管理资源

> 请记住：
>
> - 为防止资源泄露，请使用RAII（Resource Acquisition Is Initialization）对象，它们在构造函数中获得资源并在析构函数中释放资源。
> - 两个常被使用的RAII class分别是tr1::shared_ptr和auto_ptr。前者通常是最佳选择，因为其copy行为比较直观。若选择auto_ptr，复制动作会使它（被复制物）指向NULL。





# 条款14：在资源管理类中小心copying行为

> 请记住：
>
> - 复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。
> - 普遍而常见的RAII class copying行为是：抑制copying、施行引用计数法（reference counting）。





# 条款15：在资源管理类中提供对原始资源的访问

> 请记住：
>
> - API往往要求访问原始资源（raw resource），所以每一个RAII class应该提供一个“取得其所管理资源”的方法。
> - 对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全，但隐式转换对客户比较方便。



资源管理类很棒，它们能够避免内存泄露的危险。然而很多API需要直接调用原始资源。这时候你需要一个RAII对象转换为其所含的原始资源。有两个做法可以达到目标：显式转换和隐式转换。

shared_ptr和auto_ptr都提供一个get成员函数，用来执行显式转换，也就是会返回智能指针内部的原始指针（的附件）。

shared_ptr和auto_ptr也重载了指针取值操作符（operator->和operator*），它们允许隐式转换至底层原始指针。





# 条款16：成对使用new和delete时要采取相同的形式

> 请记住：
>
> - 如果你在new表达式中使用[]，必须在相应的delete表达式中也使用[]。如果你在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]。



当你使用new动态生成对象时，有两件事情发生。第一，（通过名为operator new的函数）内存会被分配出来。第二，针对此内存会有一个（或多个）构造函数被调用。

当你使用delete销毁对象时，也有两件事情发生。针对此内存会有一个（或多个）析构函数被调用，然后内存才会（通过operator delete函数）被释放。

根据以上的规则不难得出，调用new使用[]则必须在相应的delete时也使用[]，反之同理。

这个规则在使用typedef时请尤其注意。举个例子：

```cpp
typedef int array[10];	//对一个整形数组起别名
int *p = new array;	//等价于int *p = new int[10];
...
delete p;	//错误！
delete[] p;	//正确
```

为了避免诸如此类的错误，尽量不要对数组形式的对象做typedef，而最好使用STL容器代替。





# 条款17：以独立语句将new对象置入智能指针

> 请记住：
>
> - 以独立语句将new对象存储于（置入）智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露。





