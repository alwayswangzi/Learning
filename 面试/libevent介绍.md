# Libevent库介绍

## 1. 为什么使用libevent库？

1. libevent是基于事件驱动的高性能网络库；
2. 轻量，跨平台，专注于网络事件，不像Asio那样过于追求通用化；
3. 支持多种I/O复用技术；
4. 将I/O事件、定时器事件和信号事件有机的统一起来；
5. 支持注册事件的优先级划分。

## 2. Libevent有哪些组件？

- **evutil**：用于抽象不同平台网络实现差异的通用功能。
- **event_base&event**：libevent的核心，为各种平台特定的、基于事件的非阻塞 IO后端提供抽象API，让程序可以知道套接字何时已经准备好，可以读或者写，并且处理基本的超时功能，检测OS信号。
- **bufferevent**：为libevent基于事件的核心提供使用更方便的封装。除了通知程序套接字已经准备好读写之外，还让程序可以请求缓冲的读写操作，可以知道何时IO已经真正发生。
- **evbuffer**：在bufferevent层之下实现了缓冲功能，并且提供了方便有效的访问函数。

## 3. libevent事件和数据缓冲介绍

[libevent库介绍--事件和数据缓冲](http://www.cnblogs.com/alwayswangzi/p/7301449.html)

### 3.1 event_base

event_base是一个事件集合的结构体，检测里面的事件哪个是激活的。在使用libevent函数之前要分配一个或多个libevent对象，一个线程只能有event_base。

event_base处理过程主要如下：

1. 调用event_base_new()创建一个event_base；
2. 用event_new()和event_add()向 event_base注册事件；
3. 调用event_base_loop()或者event_base_dispatch()函数，循环等待事件并且通知事件的发生；
4. 调用event_base_loopexit()或者event_base_loopbreak()移除所有已注册的事件之前停止活动的事件循环；
5. 使用完 event_base 之后，使用event_base_free()进行释放。

### 3.2 event

libevent 的基本操作单元是事件。每个事件代表一组条件的集合，这些条件包括：

- 文件描述符已经就绪，可以读取或者写入；
- 文件描述符变为就绪状态，可以读取或者写入（仅对于边沿触发 I/O）；
- 超时事件；
- 信号事件；
- 用户触发事件。

所有事件具有相似的生命周期，事件的状态熟悉有如下几种：

1. **已初始化状态（initialized）**：调用 libevent 函数设置事件并且关联到event_base 之后事件进入已初始化状态。

2. **未决状态（pending）**：将事件添加到event_base 中后进入未决状态。

3. **激活状态（active）**：

   1. 在未决状态下，如果触发事件的条件发生（比如说，文件描述符的状态改变或者超时时间到达），则事件进入激活状态，（用户提供的）事件回调函数将被执行。
   2. 如果事件被配置为持久的（persistent），则事件将保持为未决状态。否则，在执行完回调之后，事件不再是未决的。
   3. 删除操作可以让未决事件成为非未决（已初始化）的， 添加操作可以让非未决事件再次成为未决的。


event的处理过程如下：

1. 使用event_new()接口创建事件；
2. 设置事件标志；
3. 设置事件的未决和非未决状态。设置未决事件调用event_add()，设置非未决事件调用event_del()；
4. 设置事件是一次触发的还是持久的。一次触发事件调用event_base_once()；
5. 释放事件（optional），调用event_free()。

### 3.3 bufferevent

很多时候，除了响应事件之外，应用还希望做一定的数据缓冲。比如说，写入数据的时候 ，通常的运行模式是：

1. 决定要向连接写入一些数据，把数据放入到缓冲区中；
2. 等待连接可以写入；
3. 写入尽量多的数据；
4. 记住写入了多少数据，如果还有数据要写入，等待连接再次可以写入。

bufferevent 由一个底层的传输端口（如套接字），一个读取缓冲区和一个写入缓冲区组成。与通常的当事件在底层传输端口已经就绪，可以读取或者写入的时候立即执行回调不同的是，bufferevent 在读取或者写入了足够量的数据之后再调用用户提供的回调。

### 3.4 evbuffer

每个 bufferevent 都有一个输入缓冲区和一个输出缓冲区 ，它们的类型都是“struct evbuffer”。 有数据要写入到 bufferevent 时，添加数据到输出缓冲区 ，bufferevent中有数据供读取的时候，从输入缓冲区抽取（drain）数据。 evbuffer 接口支持很多种操作。

### 3.5 水位

每个 bufferevent 有两个数据相关的回调：一个读取回调和一个写入回调。默认情况下，从底层传输端口读取了任意量的数据之后会调用读取回调；输出缓冲区中足够量的数据被清空到底层传输端口后写入回调会被调用。通过调整 bufferevent 的读取和写入 “水位 （watermarks）”可以覆盖这些函数的默认行为。

- **读取低水位**：读取操作使得输入缓冲区的数据量在此级别或者更高时，读取回调将被调用。默认值为0，所以每个读取操作都会导致读取回调被调用。
- **读取高水位**：输入缓冲区中的数据量达到此级别后, bufferevent 将停止读取，直到输入缓冲区中足够量的数据被抽取，使得数据量低于此级别。默认值是无限，所以永远不会因为输入缓冲区的大小而停止读取。
- **写入低水位**：写入操作使得输出缓冲区的数据量达到或者低于此级别时，写入回调将被调用。默认值是0，所以只有输出缓冲区空的时候才会调用写入回调。
- **写入高水位**：bufferevent没有直接使用这个水位。它在bufferevent用作另外一 个bufferevent的底层传输端口时有特殊意义。

### 3.6 数据缓冲Bufferevent总结

1. 读取写入的高低水位
2. 调用bufferevent_socket_new()创建基于套接字的 bufferevent
3. 调用bufferevent_socket_connect启动链接
4. 操作回调和启用/禁用
5. 操作bufferevent中的数据
6. bufferevent的清空操作
7. 调用bufferevent_free()释放bufferevent操作

## 4. libevent使用中的疑难问题解答

[libevent编程疑难解答](http://www.cnblogs.com/alwayswangzi/p/7293974.html)

