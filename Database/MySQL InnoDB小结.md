# MySQL InnoDB小结

## MySQL体系结构

MySQL特点：插件式体系结构。

![img](http://dl.iteye.com/upload/attachment/0064/2501/051d244c-d75d-372a-bc5a-6a14fe76a9ae.jpg)

由：

- 管理和服务组件
- 连接池组件
- sql接口组件
- 查询分析器组件
- 优化器组件
- 缓冲组件
- 插件式存储引擎
- 物理文件

组成。

## MySQL各个存储引擎

- InnoDB

  面向OLTP（Online Transaction Processing，在线事务处理）、行锁、支持外键、非锁定读、默认采用repeaable（可重复读）级别、通过next-key locking策略避免幻读、插入缓冲、二次写、自适应哈希索引、预读

- MyISAM

  不支持事务、表锁、全文索引、适合OLAP（Online  Analysis Processing，在线分析处理）。其中myd:放数据文件，myi:放索引文件 

- ndb

  集群存储引擎，share nothing，可提高可用性

- memory

  数据存放在内存中，表锁，并发性能差，默认使用哈希索引

- archive

  只支持insert和select zlib算法压缩1：10，适合存储归档数据如日志等、行锁

- maria

  目的取代myisam、缓存数据和索引、行锁、mvcc


![img](http://dl.iteye.com/upload/attachment/0064/2503/2b28ecc9-a276-3182-bbc6-a2f6e8e58a97.jpg)





## InnoDB特性

### 主体系结构

默认7个后台线程。

4个IO Thread、

- insert buffer
- log
- read
- write

1个Master Thread（优先级最高）、

1个锁（lock）监控线程、

1个错误监控线程，可以通过 `SHOW ENGINE innodb STATUS` 来查看。

新版本已对默认的read thread和write thread增大到4个，可以通过 `SHOW VARIABLES LIKE 'innodb_io_thread%'` 查看。

### 存储引擎组成

- 缓冲池（buffer pool）
- 重做日志缓冲（redo log buffer）
- 额外的内存池（additional memory pool）

![img](http://dl.iteye.com/upload/attachment/0064/2505/7a6f60a9-bc4a-30e5-ba13-859e65c7e3de.jpg)



### 缓冲池

最大块内存，用来存放各种数据的缓存包括：

- 有索引页
- 数据页
- undo页
- 插入缓冲
- 自适应哈希索引
- innodb存储的锁信息
- 数据字典信息等。

工作方式总是将数据库文件按页（每页16K）读取到缓冲池，然后按最近最少使用（LRU）的算法来保留在缓冲池中的缓存数据。如果数据库文件需要修改，总是首先修改在缓存池中的页（发生修改后即为脏页），然后再按照一定的频率将缓冲池的脏页刷新到文件。

### 日志缓冲

将重做日志先放入这个缓冲区，然后按照一定的频率刷新到重做日志文件。

### Master Thread

主循环（loop）执行每秒一次的操作：

- 日志缓冲刷新到磁盘，即使这个事务还没有提交（总是执行，所以再大的事务commit的时间也是很快的）
- 合并插入缓冲（innodb当前一秒发生的io次数小于5次则执行）
- 至多刷新100个innodb的缓冲池中的脏页到磁盘（超过配置的脏页所占缓冲池比例则执行，在配置文件中innodb_max_dirty_pages_pac决定，默认是90，新版本是75，google建议是80）
- 如果当前没用用户活动，切换到backgroud loop


主循环每10秒一次执行的操作：

- 刷新100个脏页到磁盘（过去10秒IO操作小于200次则执行）
- 合并至多5个插入缓冲（总是）
- 将日志缓冲到磁盘（总是）
- 删除无用的Undo页（总是）
- 刷新100个或者10个脏页到磁盘（有超过70%的脏页，刷新100个脏页，否则刷新10个脏页）
- 产生一个检查点

background loop，若当前没有用户活动（数据库空闲）时或者数据库关闭时，就会切换到这个循环：

- 删除无用的undo页（总是）
- 合并20个插入缓冲（总是）
- 跳回到主循环（总是）
- 不断刷新100个页，直到符合条件（可能在flush loop中完成）

如果flush loop中也没有什么事情可以做了，InnoDB存储引擎会切换到suspend_loop，将master thread挂起，等待事件的发生。若启用了InnoDB存储引擎，却没有使用任何InnoDB存储引擎的表，那么master thread总是处于挂起状态。



### 插入缓冲

Insert Buffer是物理页的一个组成部分，而不是缓冲池的一部分。根据B+树算法的特点，插入数据的时候主键索引是顺序的，不会造成数据库的随机读取。而对于非聚集索引（即辅助索引），叶子节点的插入不再是顺序的了，这时需要离散的访问非聚集索引，插入性能降低。

InnoDB引入插入缓冲，判断非聚集索引页是否在缓冲池中，如果在则直接插入，如果不在则先放在插入缓冲区中，然后根据上述master thread介绍的，会有一定频率的将插入缓冲合并。

此外，辅助索引并不是唯一的，因为在插入到插入缓冲时，并不去查找索引页的情况，否则仍然会造成随机读，失去插入缓冲的意义了。

插入缓冲可能会占缓冲池中内存，默认也能会占到1/2，所以可以将这个值调小点，到1/3。通过IBUF_POOL_SIZE_PER_MAX_SIZE来设置，2表示1/2,3表示1/3。 



### 两次写

它带来InnoDB数据的可靠性。如果写失效，可以通过重做日志进行恢复，但是重做日志中记录的是对页的物理操作，如果页本身损坏，再对其进行重做是没有意义的。所以，在应用重做日志之前，需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是double write。

恢复数据 = 页副本 + 重做日志

![img](http://dl.iteye.com/upload/attachment/0064/2507/1fe184a3-3358-3c21-a248-844e1c713e50.jpg)



### 自适应哈希索引

InnoDB存储引擎提出一种自适应哈希索引，存储引擎会监控对表上索引的查找，如果观察到建立建立哈希索引会带来速度的提升，则建立哈希索引，所以称之为自适应的。自适应哈希索引只能用来搜索等值的查询，如  `SELECT * FROM table WHERE index_col = '***'` , 此外自适应哈希是由InnoDB存储引擎控制的，我们只能通过innodb_adaptive_hash_index来禁用或启用，默认开启。



## MySQL文件

### 参数文件

告诉Mysql实例启动时在哪里可以找到数据库文件，并且指定某些初始化参数，这些参数定义了某种内存结构的大小等设置。用文件存储，可编辑，若启动时加载不到则不能成功启动（与其他数据库不同）。

参数有动态和静态之分，静态相当于只读，动态是可以set的。如我们通过 `SHOW VARIABLES LIKE '***'` 查出来的key、value值，是可以通过 `SET key = value` 直接修改的。同时，修改时还有作用域之分，即这个session个有效和全局有效，在对应的key前加上session或global即可，如：
`SELECT @@seesion.read_buffer_size`
`SET @@global.read_buffer_size`

### 日志文件

用来记录Mysql实例对某种条件做出响应时写入的文件。如错误日志文件、二进制日志文件、慢查询日志文件、查询日志文件等。

### 二进制文件

不记录查询，只记录对数据库所有的修改操作。目的是为了恢复（point-in-time修复）和复制。

### 重做日志文件

实例和介质失败，重做日志文件就能派上用场，如数据库掉电，InnoDB存储引擎会使用重做日志恢复到掉电前的时刻，以此来保证数据的完整性。

**二进制日志和重做日志的区别**：

- 首先，二进制日志会记录所有与Mysql有关的日志记录，包括InnoDB、MyISAM、Heap等其他存储引擎的日志。而InnoDB存储引擎重做日志只存储有关其本身的事务日志；
- 其次内容不同，不管将二进制日志文件记录的格式设为STATEMENT还是ROW，又或者是MIXED，其记录的都是关于一个事务的具体操作内容。而InnoDB存储引擎的重做日志文件记录的关于每个页的更改的物理情况；
- 此外，写入时间不同。二进制日志文件是在事务提交前进行记录的，而在事务进行的过程中，不断有重做日志条目被 写入重做日志文件中。



## MySQL InnoDB表

**表空间**：表空间可看做是InnoDB存储引擎逻辑结构的最高层。 

**段**：表空间由各个段组成，常见的段有数据段、索引段、回滚段等。 

**区**：由64个连续的页组成，每个页大小为16kb，即每个区大小为1MB。 

**页**：每页16kb，且不能更改。常见的页类型有：数据页、Undo页、系统页、事务数据页、插入缓冲位图页、插入缓冲空闲列表页、未压缩的二进制大对象页、压缩的二进制大对象页。 

**行**：InnoDB存储引擎是面向行的(row-oriented)，每页最多允许存放7992行数据。 

**行记录格式**：常见两种行记录格式Compact和Redundant，mysql5.1版本后，主要是Compact行记录格式。对于Compact，不管是char型还是varchar型，null型都是不占用存储空间的；对于Redudant,varchar的null不占用空间，char的null型是占用存储空间的。 

varchar类型的长度限制是65535，其实达不到，会有别的开销，一般是65530左右，这还跟选取的字符集有关。此外这个长度限制是一整行的，例如：
`create table test(a varchar(22000), b varchar(22000), c varchar(22000)) charset=latin1 engine=innodb`
也会报错。 

